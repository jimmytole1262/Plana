[
  {
    "projectId": "5fd7811d-34b2-4409-a932-5babd1745d08",
    "testId": "546d3e45-1414-49df-aea6-6b662f4b571d",
    "userId": "4468a4d8-90e1-70e7-39d4-2758f4f621c3",
    "title": "TC001-user registration functionality",
    "description": "Test the user registration endpoint to ensure new users can register successfully with valid data, and that passwords are encrypted and stored securely.",
    "code": "import requests\nimport hashlib\nimport time\n\nBASE_URL = \"http://localhost:5500\"\nTIMEOUT = 30\n\nAUTH_HEADER = {\n    \"Authorization\": \"Basic Sm1teSBUb2xlOkptaW15dG9sZUAyMDMw\"\n}\n\ndef test_user_registration_functionality():\n    url = f\"{BASE_URL}/users/register\"\n    # Construct a unique username and email to avoid conflicts\n    timestamp = str(int(time.time()))\n    test_user = {\n        \"username\": f\"testuser_{timestamp}\",\n        \"email\": f\"testuser_{timestamp}@example.com\",\n        \"password\": \"TestPassword@123\"\n    }\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    try:\n        # Register new user\n        response = requests.post(url, json=test_user, headers=headers, timeout=TIMEOUT)\n        assert response.status_code == 201 or response.status_code == 200, f\"Expected 200/201, got {response.status_code}\"\n        data = response.json()\n        # Validate response contains 'id' and 'user_id'\n        assert \"id\" in data, \"Response JSON missing 'id'\"\n        assert \"user_id\" in data, \"Response JSON missing 'user_id'\"\n        # Validate user_id matches id\n        assert data[\"id\"] == data[\"user_id\"], \"'id' and 'user_id' do not match\"\n        # Password should not be returned in response\n        assert \"password\" not in data, \"Password found in response JSON\"\n        \n    finally:\n        # Cleanup: Attempt to delete the created user if API supports it\n        # Assuming DELETE /users/{id} exists for cleanup\n        if 'data' in locals() and \"id\" in data:\n            delete_url = f\"{BASE_URL}/users/{data['id']}\"\n            try:\n                requests.delete(delete_url, timeout=TIMEOUT)\n            except Exception:\n                pass\n\ntest_user_registration_functionality()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-24T16:21:39.871Z",
    "modified": "2026-01-24T16:21:59.425Z"
  },
  {
    "projectId": "5fd7811d-34b2-4409-a932-5babd1745d08",
    "testId": "23348ba1-9d20-4b9d-90e5-797991e8a943",
    "userId": "4468a4d8-90e1-70e7-39d4-2758f4f621c3",
    "title": "TC002-user login authentication",
    "description": "Verify the user login endpoint authenticates users correctly using valid credentials and returns a valid JWT token for session management.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:5500\"\nLOGIN_ENDPOINT = \"/users/login\"\nTIMEOUT = 30\n\ndef test_user_login_authentication():\n    url = BASE_URL + LOGIN_ENDPOINT\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    payload = {\n        \"email\": \"jimmy.tole@example.com\",\n        \"password\": \"Jimmytole@2030\"\n    }\n\n    try:\n        response = requests.post(url, json=payload, headers=headers, timeout=TIMEOUT)\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\n    assert response.status_code == 200, f\"Expected status code 200, got {response.status_code}\"\n    try:\n        data = response.json()\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n\n    # Validate presence of JWT token (assuming token is returned in a field named 'token')\n    assert \"token\" in data, \"Response JSON does not contain 'token'\"\n    token = data.get(\"token\")\n    assert isinstance(token, str) and len(token) > 0, \"Token is empty or not a string\"\n\n\ntest_user_login_authentication()\n",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-24T16:21:39.877Z",
    "modified": "2026-01-24T16:22:23.873Z"
  },
  {
    "projectId": "5fd7811d-34b2-4409-a932-5babd1745d08",
    "testId": "d0340993-127b-404f-abf9-f1fb6d05e6e2",
    "userId": "4468a4d8-90e1-70e7-39d4-2758f4f621c3",
    "title": "TC003-event creation by admin",
    "description": "Test the event creation endpoint to confirm that administrators can create new events with all required details and that the event is stored correctly.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:5500\"\nAUTH = HTTPBasicAuth(\"Jimmy Tole\", \"Jimmytole@2030\")\nTIMEOUT = 30\n\ndef test_event_creation_by_admin():\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    event_payload = {\n        \"title\": \"Annual Tech Conference 2026\",\n        \"description\": \"A conference covering the latest in technology trends and innovations.\",\n        \"location\": \"Convention Center, Cityville\",\n        \"start_date\": \"2026-10-10T09:00:00Z\",\n        \"end_date\": \"2026-10-12T17:00:00Z\",\n        \"capacity\": 300,\n        \"price\": 199.99,\n        \"categories\": [\"Technology\", \"Conference\"],\n        \"organizer\": \"Plana Events Admin\",\n        \"is_approved\": True\n    }\n    created_event_id = None\n    try:\n        # Create new event as admin\n        response = requests.post(\n            f\"{BASE_URL}/events/createEvent\",\n            auth=AUTH,\n            headers=headers,\n            json=event_payload,\n            timeout=TIMEOUT\n        )\n        assert response.status_code == 201 or response.status_code == 200, f\"Unexpected status code: {response.status_code}\"\n        resp_json = response.json()\n        # Validate that 'id' and event details exist in response per schema updates\n        assert \"id\" in resp_json, \"Response missing event 'id'\"\n        assert \"title\" in resp_json and resp_json[\"title\"] == event_payload[\"title\"], \"Event title mismatch\"\n        assert \"description\" in resp_json and resp_json[\"description\"] == event_payload[\"description\"], \"Event description mismatch\"\n        created_event_id = resp_json[\"id\"]\n        # Validate other relevant fields returned\n        assert resp_json.get(\"location\") == event_payload[\"location\"], \"Event location mismatch\"\n        assert resp_json.get(\"capacity\") == event_payload[\"capacity\"], \"Event capacity mismatch\"\n        assert resp_json.get(\"price\") == event_payload[\"price\"], \"Event price mismatch\"\n        assert isinstance(resp_json.get(\"categories\"), list), \"Categories should be a list\"\n        assert resp_json.get(\"is_approved\") is True, \"Event should be approved\"\n    finally:\n        # Cleanup: delete the created event\n        if created_event_id:\n            try:\n                delete_response = requests.delete(\n                    f\"{BASE_URL}/events/{created_event_id}\",\n                    auth=AUTH,\n                    timeout=TIMEOUT\n                )\n                assert delete_response.status_code == 200 or delete_response.status_code == 204, f\"Failed to delete event with id {created_event_id}\"\n            except Exception:\n                pass\n\ntest_event_creation_by_admin()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-24T16:21:39.882Z",
    "modified": "2026-01-24T16:22:01.702Z"
  },
  {
    "projectId": "5fd7811d-34b2-4409-a932-5babd1745d08",
    "testId": "b1d69c64-dfc6-46cf-ad44-23c9d8ea5ffb",
    "userId": "4468a4d8-90e1-70e7-39d4-2758f4f621c3",
    "title": "TC004-view all events listing",
    "description": "Verify the endpoint for viewing all events returns a complete and accurate list of events available for users to browse.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:5500\"\nAUTH_USERNAME = \"Jimmy Tole\"\nAUTH_PASSWORD = \"Jimmytole@2030\"\nTIMEOUT = 30\n\ndef test_view_all_events_listing():\n    url = f\"{BASE_URL}/events/viewAllEvents\"\n    try:\n        response = requests.get(url, auth=HTTPBasicAuth(AUTH_USERNAME, AUTH_PASSWORD), timeout=TIMEOUT)\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\n    assert response.status_code == 200, f\"Expected status code 200, got {response.status_code}\"\n\n    try:\n        data = response.json()\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n\n    # The response should be a list (possibly empty) of events\n    assert isinstance(data, list), f\"Expected response to be a list, got {type(data)}\"\n\n    # Each event should be a dict containing at least 'id', 'user_id', and/or 'event_id'\n    for event in data:\n        assert isinstance(event, dict), f\"Expected each event to be a dict, got {type(event)}\"\n        assert 'id' in event, \"'id' field missing from event\"\n        # Either user_id or event_id or both should be present\n        has_user_id = 'user_id' in event\n        has_event_id = 'event_id' in event\n        assert has_user_id or has_event_id, \"Event must contain at least 'user_id' or 'event_id'\"\n\ntest_view_all_events_listing()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-24T16:21:39.887Z",
    "modified": "2026-01-24T16:22:05.996Z"
  },
  {
    "projectId": "5fd7811d-34b2-4409-a932-5babd1745d08",
    "testId": "754a4c39-0829-45e7-98e8-ae166bad0a5b",
    "userId": "4468a4d8-90e1-70e7-39d4-2758f4f621c3",
    "title": "TC005-event booking process",
    "description": "Test the booking creation endpoint to ensure users can book events successfully, with real-time ticket availability checks and booking confirmation.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:5500\"\nAUTH = HTTPBasicAuth(\"Jimmy Tole\", \"Jimmytole@2030\")\nHEADERS = {\"Content-Type\": \"application/json\"}\nTIMEOUT = 30\n\ndef test_event_booking_process():\n    # Step 1: Get all events to find one with available tickets\n    events_resp = requests.get(f\"{BASE_URL}/events/viewAllEvents\", auth=AUTH, headers=HEADERS, timeout=TIMEOUT)\n    assert events_resp.status_code == 200, f\"Failed to get events: {events_resp.text}\"\n    events = events_resp.json()\n    assert isinstance(events, list), f\"Events response is not a list: {events}\"\n\n    # Find an event with available tickets (assuming event object has \"tickets_available\" or similar)\n    event_to_book = None\n    for event in events:\n        if isinstance(event, dict) and event.get(\"tickets_available\", 0) > 0:\n            event_to_book = event\n            break\n\n    # If no event has tickets or no events available, create a new event first\n    event_id = None\n    created_event_id = None\n    if event_to_book is None:\n        # Create a new event (dummy minimal required fields)\n        event_payload = {\n            \"title\": \"Test Event for Booking\",\n            \"description\": \"Event created for booking test\",\n            \"date\": \"2030-12-31T20:00:00Z\",\n            \"location\": \"Test Venue\",\n            \"tickets_available\": 10,\n            \"price\": 50.0\n        }\n        create_event_resp = requests.post(f\"{BASE_URL}/events/createEvent\", auth=AUTH, headers=HEADERS, json=event_payload, timeout=TIMEOUT)\n        assert create_event_resp.status_code == 201, f\"Failed to create event: {create_event_resp.text}\"\n        created_event = create_event_resp.json()\n        assert \"id\" in created_event, f\"No event ID returned on create: {created_event}\"\n        created_event_id = created_event[\"id\"]\n        event_id = created_event_id\n    else:\n        event_id = event_to_book[\"id\"]\n\n    # Step 2: Create booking for the selected event\n    booking_payload = {\n        \"event_id\": event_id,\n        \"user_id\": None  # user_id is usually obtained from user profile or JWT; assume backend infers from auth or use dummy\n    }\n    # Since auth is basic token, backend may identify user from that; omit user_id if not required or set to None/null\n    # Remove user_id if None to avoid sending null\n    if booking_payload[\"user_id\"] is None:\n        booking_payload.pop(\"user_id\")\n\n    try:\n        create_booking_resp = requests.post(f\"{BASE_URL}/bookings/createBooking\", auth=AUTH, headers=HEADERS, json=booking_payload, timeout=TIMEOUT)\n        assert create_booking_resp.status_code == 201, f\"Booking creation failed: {create_booking_resp.text}\"\n        booking = create_booking_resp.json()\n        # Validate booking response fields\n        assert \"id\" in booking, \"Booking id missing in response\"\n        assert \"user_id\" in booking, \"Booking user_id missing in response\"\n        assert \"event_id\" in booking, \"Booking event_id missing in response\"\n        assert booking[\"event_id\"] == event_id, \"Booked event_id mismatch\"\n        # Optionally check booking confirmation details\n        assert isinstance(booking.get(\"confirmation\"), str) or booking.get(\"confirmation\") is None, \"Invalid confirmation field\"\n    finally:\n        # Cleanup: Delete created booking if booking creation succeeded\n        if 'booking' in locals() and booking.get(\"id\"):\n            booking_id = booking[\"id\"]\n            resp = requests.delete(f\"{BASE_URL}/bookings/{booking_id}\", auth=AUTH, headers=HEADERS, timeout=TIMEOUT)\n            # Not assert here, just attempt cleanup\n\n        # Cleanup: Delete created event if event was created in this test\n        if created_event_id:\n            resp = requests.delete(f\"{BASE_URL}/events/{created_event_id}\", auth=AUTH, headers=HEADERS, timeout=TIMEOUT)\n            # Not assert here, just attempt cleanup\n\ntest_event_booking_process()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 78, in <module>\n  File \"<string>\", line 57, in test_event_booking_process\nAssertionError: Booking creation failed: {\"error\":\"Error booking event\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-24T16:21:39.892Z",
    "modified": "2026-01-24T16:22:10.178Z"
  }
]
